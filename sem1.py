# Императивный код для нахождения суммы чисел до n
def sum_up_to_n(n):
  result = 0
  for i in range(1, n+1):
    result += i
  return result

# Декларативный запрос для выборки имен и возрастов
# SELECT name, age FROM users WHERE age > 25;

# Декларативный код для нахождения суммы чисел до n с использованием функционального стиля
def sum_up_to_n_declarative(n):
  return sum(range(1, n+1))

# Напишите программу, которая находит сумму всех четных чисел от 1 до 100 с использованием императивного программирования (цикла).

summa = 0
for num in range(1, 101):
  if num % 2 == 0:
    summa += num
print("Сумма четных чисел: ",summa)

# Напишите программу, которая находит сумму всех четных чисел от 1 до 100 с использованием декларативного программирования (цикла).

even_numbers = [num for num in range(1,101) if num % 2 == 0]
sum_of_even_numbers = sum(even_numbers)
print("Сумма четных чисел: ",sum_of_even_numbers)

# Дан список чисел. Ваша задача - найти наибольшую возрастающую подпоследовательность в этом списке.

numbers = [3, 4, -1, 0, 6, 2, 3]
start=0                                       # Индекс конца текущей последовательности 
number_up = []                                # Список для хранения всех последовательностей

for i in range(0, len(numbers)-1):            
  if numbers[i] < numbers[i+1]:               # Если текущее число меньше следующего
    stop = i + 1                              # Увеличиваем индекс конца текущей послед-ти
  else:
    number_up.append(numbers[start:stop + 1]) # Добавляем текущую послед-ть в список
    start = i + 1                             # Обновляем индекс начала следующей послед-ти
    stop = i + 1 
    
number_up.append(numbers[start:stop + 1])     # Добавляем последнюю послед-ть в список

max_len = len(number_up[0])                   # Инициализация макс. длины послед-ти
max_i = 0
for i in range(len(number_up)):               # Проход по всем последовательностям
  if len(number_up[i]) > max_len:             # Если текущая послед-ть длинее максимальной
    max_len = len(number_up[i])               # Обновляем максимальную длину
    max_i = i                                 # Запоминаем индекс текущей максим. послед-ти
    
print(number_up[max_i])                       # Выводим на экран наибольшую послед-ть
